# 02. 알아둬야 할 자바스크립트
## 호출 스택
### 일반적인 동기함수
```javascript
function first() {
    second();
    console.log('1');
}

function second() {
    third();
    console.log('2');
}

function third() {
    console.log('3');
}

first();

// 실행결과
'3'
'2'
'1'
```
![호출스택](https://github.com/ljs5960/TIL/assets/54578316/be335f88-186e-45cb-8f8c-95016db52b9f)
- Anonymous는 가상의 전역 컨텍스트 (파일 시작시 생성, 파일 종료시 종료)
- LIFO 구조의 스택형태로 순서대로 쌓이고 역순으로 실행됨
- 함수 실행 완료시 스택에서 빠짐
- 호출스택이 모두 비어있을 시 프로세스 종료

### 비동기 함수
```javascript
function run() {
    console.log('2');
}

console.log('1');
setTimeout(run, 3000);
console.log('3');

// 실행결과
'1'
'3'
'2'
```
- 비동기함수(setTimeout)의 경우 BackGround에 timer(run, 3000)를 전송
  - setTimeout이 0초라 하더라도 무조건 BackGround로 이동
- JS의 특성상 CallStack, BackGround 동시에 실행
  - ```console.log('End')```, ```setTimeout(run, 3000)``` 동시 실행
- BackGround 비동기함수 실행완료시 TaskQueue 보관
- *CallStack 모두 비어있을 시 TaskQueue 보관된 함수 실행*

## const, let

```javascript
if (true) {
    var x = 3;
}
console.log(x); // 3

if (true) {
    const y = 3;
}
console.log(y); // Uncaught ReferenceError: y is not defined

function a() {
    var z = 3;
}
console.log(z); //  Uncaught ReferenceError: z is not defined
```
- ES2015 이후 var -> const, let 대체
- 차이점
  - const, let : 블록 스코프 ({} 블록 밖의 변수 접근 불가)
  - var : 함수 스코프 (function{} 제외한 블록 밖의 변수 접근 가능)

## 구조분해할당
```javascript
const ex = {a: 123, b: {c: 135, d: 146}}
const a = ex.a;
const d = ex.b.d;

const {a, b:{d}} = ex;
console.log(a); // 123

arr[1, 2, 3, 4, 5];
const[x, y, , , z] = arr;
console.log(x); // 1
```
- 같은 객체 형태로 선언 시 자동으로 분해 후 할당

## Map / Set
- ES2015 이후 추가된 자료구조
- Map은 객체, Set은 배열과 유사
- map.set('Key', 'Value'); 형태로 데이터 추가
- map.get('Key'); 형태로 데이터 출력
- set.add('Value'); 형태로 데이터 추가
- set은 중복을 허용하지 않는 배열
```javascript
const map = new Map();
map.set('a', 'b');
map.set(3, 'c');
map.set({}, 'e');
console.log(map.get(d)); // e

const set = new Set();
set.add(false);
set.add(1);
set.add('1');
set.add(1); // 중복이라 무시
console.log(set.size); // 중복이 제거되어 3
```

## 널 병합 / 옵셔널 체이닝
### 널 병합 연산자 (??)
- ES2020 추가된 연산자
- null, undefined 일 경우에만 뒤의 값 할당
- 0, '' 등 falsy값은 전부 뒤의 값 할당하는 ||연산자의 한계를 보완하기 위한 연산자
```javascript
const a = 0;
const b = a || 3; // || 연산자: 0, '', false, NaN, null, undefined -> 뒤의 값 할당
console.log(b); // 3

const c = null;
const d = c ?? 3; // ?? 연산자: null, undefined -> 뒤의 값 할당
console.log(d); // 3
```

### 옵셔널 체이닝 연산자
- 객체/함수 + '?' + .property 형태로 사용
- 객체가 Null일 경우 property를 읽지않아 TypeError 발생 방지
```javascript
console.log(c.d); // TypeError: Cannot read properties of null (reading d)

console.log(c?.d); // 문제없음
```